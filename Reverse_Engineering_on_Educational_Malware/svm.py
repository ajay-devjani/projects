# Details:
# Written by: Ajay Devjani, M.Tech INSE
# Project Co-partner: Rushaan Qureshi, M.Tech INSE
# Supervised by Prof: Makan Pourzandi

import logging
import time

# Importing the libraries
import pandas as pd
from numpy import mean
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split, KFold, cross_val_score
from sklearn.preprocessing import OneHotEncoder
from sklearn.svm import LinearSVC


# Function definition to calculate accuracy of "Linear SVM".
# Input: size: Specifies size of n-gram.
# Input: is_dynamic: Specifies whether it is static or dynamic analysis.
# Output: List of accuracies of Linear SVM Analysis (consists of all n-grams and folds).
def linear_svm(size=3, is_dynamic=False):
    logging.basicConfig(filename='reverse_engineering.log', level=logging.INFO)
    # Importing the dataset according to Static/Dynamic Analysis.
    if is_dynamic:
        dataset = pd.read_csv('./training/training_dynamic_' + str(size) + '_gram.txt')
        rep_type = 'Dynamic '
    else:
        dataset = pd.read_csv('./training/training_' + str(size) + '_gram.txt')
        rep_type = 'Static '
    # Taking first column of CSV as API sequence (separated with bar: '|')
    # For more details, refer n_grams_creator.py and dynamic_csv_txt.py.
    api_combination = dataset.iloc[:, 0].values
    # Taking last column as 0 for "Benign" and 1 for "Malware".
    is_malware = dataset.iloc[:, -1].values
    start_time = time.time()
    # Encoding labels
    vec = OneHotEncoder()
    api_combination_encoded = vec.fit_transform(api_combination.reshape(-1, 1))
    # Test Train split: 20% test and 80% training data.
    X_train, X_test, y_train, y_test = train_test_split(api_combination_encoded, is_malware, test_size=0.20,
                                                        random_state=0)
    # Training the Linear SVM model on the Training set
    # Defining Classifier as Linear SVM
    classifier = LinearSVC()
    # Fitting the model.
    classifier.fit(X_train, y_train)
    # Predicting the Test set results without folds.
    y_pred = classifier.predict(X_test)
    ac = round(accuracy_score(y_test, y_pred) * 100, 6)
    print(rep_type + "Accuracy of SVM with %d grams: %f" % (size, ac))
    logging.info(rep_type + "Accuracy of SVM with %d grams: %f" % (size, ac))
    exec_time = time.time() - start_time
    print("Execution Time: %f" % exec_time)
    logging.info("Execution Time: %f" % exec_time)
    # Defining folds.
    folds = [5, 10, 20]
    accuracies = [ac]
    for k in folds:
        start_time = time.time()
        # Defining split folds with shuffle.
        cv = KFold(n_splits=k, shuffle=True, random_state=1)
        # Calculating cross validation score of every fold, then taking mean of all validation scores
        # followed by rounding it off to 6 decimal places.
        acc = round(mean(cross_val_score(classifier, api_combination_encoded, is_malware,
                                         scoring='accuracy', cv=cv, n_jobs=-1)) * 100, 6)
        print('\t' + rep_type + 'SVM> Folds=%d, Accuracy=%f' % (k, acc))
        logging.info('\t' + rep_type + 'SVM> Folds=%d, Accuracy=%f' % (k, acc))
        exec_time = time.time() - start_time
        print('\t' + "Execution Time: %f" % exec_time)
        logging.info('\t' + "Execution Time: %f" % exec_time)
        accuracies.append(acc)
    # Returning Accuracy List
    return accuracies
